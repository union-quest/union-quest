{"version":3,"file":"wallet-bec7b7de.js","sources":["../../../../../src/lib/web/notifications.ts","../../../../../src/lib/blockchain/contracts.ts","../../../../../src/lib/utils/eth/networks.ts","../../../../../src/lib/utils/web.ts","../../../../../src/lib/config.ts","../../../../../src/lib/time.ts","../../../../../src/lib/blockchain/chainTempo.ts","../../../../../src/lib/blockchain/wallet.ts"],"sourcesContent":["import {writable} from 'svelte/store';\n\ntype Notification = {\n  id?: string;\n  delay: number;\n  onAcknowledge?: () => void;\n  title: string;\n  text: string;\n  type: 'error' | 'success' | 'info' | 'warning';\n};\n\ntype CurrentNotification = {\n  current?: Notification;\n};\n\nconst createStore = () => {\n  const recorded: Record<string, boolean> = {};\n  const pending: Notification[] = [];\n  const data: CurrentNotification = {\n    current: undefined,\n  };\n\n  let timeout: NodeJS.Timeout;\n\n  const {subscribe, set} = writable<CurrentNotification>(data);\n\n  function setCurrent(current: Notification | undefined) {\n    data.current = current;\n    set(data);\n    if (current && current.delay) {\n      if (current.onAcknowledge) {\n        current.onAcknowledge(); // TODO delay?\n      }\n      timeout = setTimeout(acknowledge, current.delay * 1000);\n    }\n  }\n\n  function acknowledge() {\n    const current = data.current;\n    if (current && !current.delay && current.onAcknowledge) {\n      current.onAcknowledge();\n    }\n    const next = pending.shift();\n    clearTimeout(timeout);\n    setCurrent(next);\n  }\n\n  function queue(notification: Notification) {\n    if (notification.id) {\n      if (recorded[notification.id]) {\n        return;\n      }\n      recorded[notification.id] = true;\n    }\n    if (pending.length > 0 || data.current) {\n      pending.push(notification);\n    } else {\n      setCurrent(notification);\n    }\n  }\n\n  return {\n    subscribe,\n    queue,\n    acknowledge,\n    clear: () => {\n      pending.splice(0, pending.length);\n      acknowledge();\n    },\n  };\n};\n\nexport const notifications = createStore();\n\n// USEFUL FOR DEBUGGING:\nif (typeof window !== 'undefined') {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  (window as any).notifications = notifications;\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n}\n","import _contractsInfos from '$lib/contracts.json';\nimport {readable} from 'svelte/store';\n\nexport const initialContractsInfos = _contractsInfos;\n\nlet _set;\nexport const contractsInfos = readable(_contractsInfos, (set) => {\n  _set = set;\n});\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    _set(newModule.initialContractsInfos);\n  });\n}\n","export const chainNames: {[chainId: string]: string} = {\n  '1': 'mainnet',\n  '3': 'ropsten',\n  '4': 'rinkeby',\n  '5': 'goerli',\n  '42': 'kovan',\n  '1337': 'localhost chain',\n  '31337': 'localhost chain',\n};\n\nexport function nameForChainId(chainId: string): string {\n  const name = chainNames[chainId];\n  if (name) {\n    return name;\n  }\n  return `chain with id ${chainId}`;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function getParamsFromURL(url: string): {params: Record<string, string>; pathname?: string} {\n  if (!url) {\n    return {params: {}, pathname: ''};\n  }\n  const obj: Record<string, string> = {};\n  const hash = url.lastIndexOf('#');\n\n  let cleanedUrl = url;\n  if (hash !== -1) {\n    cleanedUrl = cleanedUrl.slice(0, hash);\n  }\n\n  const question = cleanedUrl.indexOf('?');\n  if (question !== -1) {\n    cleanedUrl\n      .slice(question + 1)\n      .split('&')\n      .forEach((piece) => {\n        const [key, val = ''] = piece.split('=');\n        obj[decodeURIComponent(key)] = val === '' ? 'true' : decodeURIComponent(val);\n      });\n  }\n\n  let pathname = cleanedUrl.slice(0, question) || '';\n  if (pathname && !pathname.endsWith('/')) {\n    pathname += '/';\n  }\n  return {params: obj, pathname};\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function getParamsFromLocation(): {params: Record<string, string>; pathname?: string} {\n  if (typeof window === 'undefined') {\n    return {params: {}};\n  }\n  return getParamsFromURL(window.location.href);\n}\n\nexport function getHashParamsFromLocation(str?: string): Record<string, string> {\n  if (typeof window === 'undefined') {\n    return {};\n  }\n  const url = str || window.location.hash;\n  const obj: Record<string, string> = {};\n  const hash = url.lastIndexOf('#');\n\n  if (hash !== -1) {\n    url\n      .slice(hash + 1)\n      .split('&')\n      .forEach((piece) => {\n        const [key, val = ''] = piece.split('=');\n        obj[decodeURIComponent(key)] = decodeURIComponent(val);\n      });\n  }\n  return obj;\n}\n\nexport function queryStringifyNoArray(query: Record<string, string>): string {\n  let str = '';\n  for (const key of Object.keys(query)) {\n    const value = query[key];\n    str += `${str === '' ? '?' : '&'}${key}=${value}`;\n  }\n  return str;\n}\n\nexport function rebuildLocationHash(hashParams: Record<string, string>): void {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  let reconstructedHash = '';\n  Object.entries(hashParams).forEach((param) => {\n    if (reconstructedHash === '') {\n      reconstructedHash += '#';\n    } else {\n      reconstructedHash += '&';\n    }\n    reconstructedHash += param.join('=');\n  });\n\n  if ('replaceState' in window.history) {\n    window.history.replaceState(\n      '',\n      document.title,\n      window.location.pathname + window.location.search + reconstructedHash\n    );\n  } else {\n    // Prevent scrolling by storing the page's current scroll offset\n    const {scrollTop, scrollLeft} = document.body;\n    window.location.hash = '';\n\n    // Restore the scroll offset, should be flicker free\n    document.body.scrollTop = scrollTop;\n    document.body.scrollLeft = scrollLeft;\n  }\n}\n\nasync function chrome76Detection(): Promise<boolean> {\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    const {quota} = await navigator.storage.estimate();\n    return quota !== undefined && quota < 120000000;\n  }\n  return false;\n}\n\nfunction isNewChrome(): boolean {\n  const pieces = navigator.userAgent.match(/Chrom(?:e|ium)\\/([0-9]+)\\.([0-9]+)\\.([0-9]+)\\.([0-9]+)/);\n  if (pieces === null || pieces.length !== 5) {\n    return false;\n  }\n  const major = pieces.map((piece) => parseInt(piece, 10))[1];\n  return major >= 76;\n}\n\nexport function isPrivateWindow(): Promise<boolean | null> {\n  return new Promise((resolve) => {\n    try {\n      const isSafari =\n        navigator.vendor &&\n        navigator.vendor.indexOf('Apple') > -1 &&\n        navigator.userAgent &&\n        navigator.userAgent.indexOf('CriOS') === -1 &&\n        navigator.userAgent.indexOf('FxiOS') === -1;\n\n      if (isSafari) {\n        // Safari\n        let e = false;\n        if ((window as any).safariIncognito) {\n          e = true;\n        } else {\n          try {\n            (window as any).openDatabase(null, null, null, null);\n            window.localStorage.setItem('test', '1');\n            resolve(false);\n          } catch (err) {\n            e = true;\n            resolve(true);\n          }\n          // eslint-disable-next-line no-unused-expressions, no-void\n          void !e && ((e = !1), window.localStorage.removeItem('test'));\n        }\n      } else if (navigator.userAgent.includes('Firefox')) {\n        // Firefox\n        const db = indexedDB.open('test');\n        db.onerror = () => {\n          resolve(true);\n        };\n        db.onsuccess = () => {\n          resolve(false);\n        };\n      } else if (\n        navigator.userAgent.includes('Edge') ||\n        navigator.userAgent.includes('Trident') ||\n        navigator.userAgent.includes('msie')\n      ) {\n        // Edge or IE\n        if (!window.indexedDB && (window.PointerEvent || window.MSPointerEvent)) {\n          resolve(true);\n        }\n        resolve(false);\n      } else {\n        // Normally ORP or Chrome\n        if (isNewChrome()) {\n          resolve(chrome76Detection());\n        }\n\n        const fs = (window as any).RequestFileSystem || (window as any).webkitRequestFileSystem;\n        if (!fs) {\n          resolve(null);\n        } else {\n          fs(\n            (window as any).TEMPORARY,\n            100,\n            () => resolve(false),\n            () => resolve(true)\n          );\n        }\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n      resolve(null);\n    }\n  });\n}\n","import {getDefaultProvider, Provider} from '@ethersproject/providers';\nimport {nameForChainId} from './utils/eth/networks';\nimport {getParamsFromLocation, getHashParamsFromLocation} from './utils/web';\n\nimport * as Sentry from '@sentry/browser';\nimport {Integrations} from '@sentry/tracing';\nimport {RewriteFrames as RewriteFramesIntegration} from '@sentry/integrations';\n\nlet root = undefined;\nif (typeof window !== 'undefined') {\n  root = window.location.protocol + '//' + window.location.host + (window as any).BASE;\n}\nconsole.log(`VERSION: ${__VERSION__}`);\n\nexport const hashParams = getHashParamsFromLocation();\nexport const {params} = getParamsFromLocation();\n// export const VERSION = '1';\n\nconst chainId = import.meta.env.VITE_CHAIN_ID as string;\nlet fallbackProviderOrUrl: string | Provider | undefined;\nlet finality = 12;\nlet blockTime = 15;\nlet nativeTokenSymbol = 'ETH';\nif (chainId !== '1') {\n  finality = 5; // TODO\n  blockTime = 10;\n  nativeTokenSymbol = 'ETH'; // TODO\n}\n\nif (chainId === '5') {\n  finality = 8; // TODO\n  blockTime = 15;\n  nativeTokenSymbol = 'ETH';\n}\n\nlet webWalletURL: string | undefined = import.meta.env.VITE_WEB_WALLET_ETH_NODE as string | undefined;\n\nlet localDev = false;\nif (chainId === '1337' || chainId === '31337') {\n  localDev = true;\n  fallbackProviderOrUrl = import.meta.env.VITE_ETH_NODE_URI_LOCALHOST as string;\n  webWalletURL = (import.meta.env.VITE_WEB_WALLET_ETH_NODE_LOCALHOST as string) || webWalletURL;\n\n  // const localEthNode = import.meta.env.VITE_ETH_NODE_URI_LOCALHOST as string;\n  // if (localEthNode && localEthNode !== '') {\n  //   fallbackProviderOrUrl = localEthNode;\n  // } else {\n  //   fallbackProviderOrUrl = 'http://localhost:8545';\n  // }\n  finality = 2;\n  blockTime = 5;\n}\n\nconst chainName = nameForChainId(chainId);\n\nif (!fallbackProviderOrUrl) {\n  const url = import.meta.env.VITE_ETH_NODE_URI as string; // TODO use query string to specify it // TODO settings\n  if (url && url !== '') {\n    fallbackProviderOrUrl = url;\n  }\n}\n\nif (fallbackProviderOrUrl && typeof fallbackProviderOrUrl === 'string') {\n  if (!fallbackProviderOrUrl.startsWith('http') && !fallbackProviderOrUrl.startsWith('ws')) {\n    // if no http nor ws protocol, assume fallbackProviderOrUrl is the network name\n    // use ethers fallback provider\n    fallbackProviderOrUrl = getDefaultProvider(fallbackProviderOrUrl, {\n      alchemy: import.meta.env.VITE_ALCHEMY_API_KEY || undefined,\n      etherscan: import.meta.env.VITE_ETHERSCAN_API_KEY || undefined,\n      infura: import.meta.env.VITE_INFURA_PROJECT_ID || undefined,\n      pocket: import.meta.env.VITE_POCKET_APP_ID || undefined,\n      quorum: 2,\n    });\n  } else {\n    fallbackProviderOrUrl = getDefaultProvider(fallbackProviderOrUrl); // still use fallback provider but use the url as is\n  }\n}\n\nconst graphNodeURL = import.meta.env.VITE_THE_GRAPH_HTTP as string;\n\nconst logPeriod = 7 * 24 * 60 * 60;\nconst deletionDelay = 7 * 24 * 60 * 60;\n\nconst lowFrequencyFetch = blockTime * 8;\nconst mediumFrequencyFetch = blockTime * 4;\nconst highFrequencyFetch = blockTime * 2;\n\nconst globalQueryParams = ['debug', 'log', 'subgraph', 'ethnode', '_d_eruda'];\n\nlet getName = () => {\n  return undefined;\n};\nfunction setGetName(func: () => string): void {\n  getName = func;\n}\n\nif (\n  import.meta.env.MODE === 'production' &&\n  import.meta.env.VITE_SENTRY_DSN &&\n  typeof import.meta.env.VITE_SENTRY_DSN === 'string'\n) {\n  Sentry.init({\n    release: __VERSION__,\n    dsn: import.meta.env.VITE_SENTRY_DSN as string,\n    beforeSend(event, hint) {\n      // Check if it is an exception, and if so, show the report dialog\n      // if (event.exception) {\n      //   console.error(`EXCEPTION`, event);\n      //   Sentry.showReportDialog({eventId: event.event_id, user: {name: getName(), email: 'noone@nowhere.eth'}});\n      // } else {\n      //   console.error(`sentry event`, event);\n      // }\n      return event;\n    },\n    integrations: [\n      new Integrations.BrowserTracing({\n        tracingOrigins: ['localhost', /^\\//], //, graphNodeURL.split('/')[0]], fails with \"has been blocked by CORS policy: Request header field sentry-trace is not allowed by Access-Control-Allow-Headers in preflight response.\"\n      }),\n      new RewriteFramesIntegration({\n        iteratee: (frame) => {\n          if (frame.filename) {\n            frame.filename = frame.filename.replace(root, '');\n          }\n          return frame;\n        },\n      }),\n    ],\n\n    // Set tracesSampleRate to 1.0 to capture 100%\n    // of transactions for performance monitoring.\n    // We recommend adjusting this value in production\n    tracesSampleRate: 1.0,\n  });\n  console.log('SENTRY ENABLED');\n  if (typeof window !== 'undefined') {\n    (window as any).generateError = (message) => {\n      const result = Sentry.captureMessage(message);\n      console.log({result});\n    };\n  }\n}\n\nexport {\n  finality,\n  fallbackProviderOrUrl,\n  webWalletURL,\n  chainId,\n  blockTime,\n  chainName,\n  nativeTokenSymbol,\n  graphNodeURL,\n  logPeriod,\n  lowFrequencyFetch,\n  mediumFrequencyFetch,\n  highFrequencyFetch,\n  globalQueryParams,\n  deletionDelay,\n  localDev,\n  setGetName,\n};\n\nif (typeof window !== 'undefined') {\n  (window as any).env = import.meta.env;\n}\n","import {blockTime} from '$lib/config';\nimport {readable} from 'svelte/store';\n\nconst performanceAvailable = typeof performance !== 'undefined'; // server\n\nexport let startTime = performanceAvailable ? (Date.now() - performance.now()) / 1000 : Date.now() / 1000;\n\nexport function now(): number {\n  if (performanceAvailable) {\n    return Math.floor(performance.now() / 1000) + startTime;\n  } else {\n    return Math.floor(Date.now() / 1000) + startTime;\n  }\n}\n\nlet _corrected = false;\nexport function correctTime(actualTime: number): void {\n  const currentTime = now();\n  const diff = actualTime - currentTime;\n  if (Math.abs(diff) > blockTime) {\n    // only adapt if difference is significant\n    startTime += diff;\n  }\n  _corrected = true;\n}\n\nexport function isCorrected(): boolean {\n  return _corrected;\n}\n\nexport const time = readable(now(), function start(set) {\n  const interval = setInterval(() => {\n    set(now());\n  }, 1000);\n\n  return function stop() {\n    clearInterval(interval);\n  };\n});\n\nif (typeof window !== 'undefined') {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as unknown as any).time = {\n    now,\n    startTime,\n    correctTime,\n    isCorrected,\n    time,\n  };\n}\n","import {blockTime} from '$lib/config';\nimport type {Provider} from '@ethersproject/abstract-provider';\nimport {logs} from 'named-logs';\nimport type {Readable} from 'svelte/store';\nconst console = logs('chainTempo');\n\nfunction removeFrom(array: unknown[], elem: unknown): void {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (array[i] === elem) {\n      array.splice(i, 1);\n      return;\n    }\n  }\n  console.log('NOT FOUND');\n}\n\nexport type ChainTempoInfo = {lastBlockNumber?: number; stale: boolean};\n\nexport type TempoListener = (chainInfo: ChainTempoInfo) => void;\n\nclass ChainTempo implements Readable<ChainTempoInfo> {\n  private blockListeners: TempoListener[] = [];\n  private currentProvider?: Provider = undefined;\n  private callback: () => void;\n  private timeout: NodeJS.Timeout;\n  private lastUpdate = 0;\n  private triggerTimeout: NodeJS.Timeout;\n  public readonly chainInfo: ChainTempoInfo = {lastBlockNumber: undefined, stale: true};\n\n  constructor(private maxTimeout: number) {}\n\n  subscribe(func: TempoListener): () => void {\n    func(this.chainInfo);\n    this.blockListeners.push(func);\n    return removeFrom.bind(null, this.blockListeners, func);\n  }\n\n  check() {\n    const now = Date.now() / 1000;\n    if (now - this.lastUpdate > this.maxTimeout - 1) {\n      console.info(`timed out... ${now}  - ${this.lastUpdate} = ${now - this.lastUpdate} > ${this.maxTimeout - 1}`);\n      this.onBlock(undefined);\n    }\n    this.timeout = setTimeout(this.check.bind(this), this.maxTimeout * 1000);\n  }\n\n  startOrUpdateProvider(provider?: Provider) {\n    if (this.currentProvider !== provider) {\n      if (this.currentProvider) {\n        console.info('stop listening for block event');\n        this.currentProvider.off('block', this.callback);\n      }\n      this.callback = this.onBlock.bind(this);\n      this.currentProvider = provider;\n      if (this.currentProvider) {\n        console.info('listening for block event');\n        this.currentProvider.on('block', this.callback);\n      }\n    }\n\n    // fallback on time as provider might not be available\n    if (!this.timeout) {\n      this.timeout = setTimeout(this.check.bind(this), this.maxTimeout * 1000);\n    }\n  }\n  private onBlock(blockNumber?: number) {\n    if (blockNumber) {\n      this.chainInfo.lastBlockNumber = blockNumber;\n      this.chainInfo.stale = false;\n    } else {\n      this.chainInfo.stale = true;\n    }\n    this.lastUpdate = Date.now() / 1000;\n    this.triggerListeners();\n  }\n\n  private triggerListeners() {\n    if (this.triggerTimeout) {\n      clearTimeout(this.triggerTimeout);\n    }\n    this.triggerTimeout = setTimeout(this.callListeners.bind(this), 0);\n  }\n\n  private callListeners() {\n    console.info(`onBlock ${this.chainInfo.lastBlockNumber}`);\n\n    for (const listener of this.blockListeners) {\n      // TODO delay them ?\n      listener(this.chainInfo); // TODO wait for each one ?\n    }\n    // TODO wait for them (if delayed) before triggering the next update?\n  }\n}\n\nexport const chainTempo = new ChainTempo(blockTime * 6);\n","import {initWeb3W} from 'web3w';\nimport {WalletConnectModuleLoader} from 'web3w-walletconnect-loader';\nimport {contractsInfos} from '$lib/blockchain/contracts';\nimport {notifications} from '../web/notifications';\nimport {webWalletURL, finality, fallbackProviderOrUrl, chainId, localDev} from '$lib/config';\nimport {isCorrected, correctTime} from '$lib/time';\nimport {base} from '$app/paths';\nimport {chainTempo} from '$lib/blockchain/chainTempo';\nimport * as Sentry from '@sentry/browser';\nimport {get} from 'svelte/store';\n\nconst walletStores = initWeb3W({\n  chainConfigs: get(contractsInfos),\n  builtin: {autoProbe: true},\n  transactions: {\n    autoDelete: false,\n    finality,\n  },\n  flow: {\n    autoUnlock: true,\n  },\n  autoSelectPrevious: true,\n  localStoragePrefix: (base && base.startsWith('/ipfs/')) || base.startsWith('/ipns/') ? base.slice(6) : undefined, // ensure local storage is not conflicting across web3w-based apps on ipfs gateways\n  options: [\n    'builtin',\n    new WalletConnectModuleLoader({\n      nodeUrl: typeof fallbackProviderOrUrl === 'string' ? fallbackProviderOrUrl : undefined,\n      chainId,\n      infuraId: 'bc0bdd4eaac640278cdebc3aa91fabe4',\n    }),\n  ],\n  fallbackNode: fallbackProviderOrUrl,\n  checkGenesis: localDev,\n});\n\nexport const {wallet, transactions, builtin, chain, balance, flow, fallback} = walletStores;\n\nfunction notifyFailure(tx: {hash: string}) {\n  notifications.queue({\n    id: tx.hash,\n    delay: 0,\n    title: 'Transaction Error',\n    text: 'The Transaction failed',\n    type: 'error',\n    onAcknowledge: () => transactions.acknowledge(tx.hash, 'failure'),\n  });\n}\n\nfunction notifyCancelled(tx: {hash: string}) {\n  notifications.queue({\n    id: tx.hash,\n    delay: 3,\n    title: 'Transaction Cancelled',\n    text: 'The Transaction Has Been Replaced',\n    type: 'info',\n    onAcknowledge: () => transactions.acknowledge(tx.hash, 'cancelled'),\n  });\n}\n\ntransactions.subscribe(($transactions) => {\n  for (const tx of $transactions.concat()) {\n    if (tx.confirmations > 0 && !tx.acknowledged) {\n      if (tx.status === 'failure') {\n        notifyFailure(tx);\n      } else if (tx.status === 'cancelled') {\n        notifyCancelled(tx);\n      } else {\n        // auto acknowledge\n        transactions.acknowledge(tx.hash, tx.status);\n      }\n    }\n  }\n});\n\nchain.subscribe(async (v) => {\n  chainTempo.startOrUpdateProvider(wallet.provider);\n  if (!isCorrected()) {\n    if (v.state === 'Connected' || v.state === 'Ready') {\n      const latestBlock = await wallet.provider?.getBlock('latest');\n      if (latestBlock) {\n        correctTime(latestBlock.timestamp);\n      }\n    }\n  }\n});\n\nfallback.subscribe(async (v) => {\n  if (!isCorrected()) {\n    if (v.state === 'Connected' || v.state === 'Ready') {\n      const latestBlock = await wallet.provider?.getBlock('latest');\n      if (latestBlock) {\n        correctTime(latestBlock.timestamp);\n      }\n    }\n  }\n});\n\nlet lastAddress: string | undefined;\nwallet.subscribe(async ($wallet) => {\n  if (lastAddress !== $wallet.address) {\n    lastAddress = $wallet.address;\n    Sentry.setUser({address: $wallet.address});\n  }\n});\n\n// TODO remove\nif (typeof window !== 'undefined') {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).walletStores = walletStores;\n}\n\nchainTempo.startOrUpdateProvider(wallet.provider);\n\ncontractsInfos.subscribe(async ($contractsInfo) => {\n  await chain.updateContracts($contractsInfo);\n});\n"],"names":["console","get"],"mappings":"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"}